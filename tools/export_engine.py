"""
Phase 6A: Engine Export — Unity / Godot Asset Package Generator

Takes pipeline output and produces engine-ready ZIP packages with:
- Properly structured sprite/audio directories
- JSON data files (paytable, reel strips, features, config)
- Auto-generated code files (C# for Unity, GDScript for Godot)
- Integration README

Supported formats: unity, godot, generic (raw JSON + assets)
"""

from __future__ import annotations
import csv
import io
import json
import os
import shutil
import zipfile
from datetime import datetime
from pathlib import Path
from typing import Optional


# ─── C# Template for Unity ───

UNITY_SLOT_CONFIG_CS = '''// Auto-generated by ARKAINBRAIN Pipeline
// Game: {game_title}
// Generated: {generated_at}
//
// Usage: Attach to a GameObject or reference via ScriptableObject.
// All data is loaded from JSON files in Resources/Data/

using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class SlotConfig
{{
    public string gameTitle = "{game_title}";
    public int gridCols = {grid_cols};
    public int gridRows = {grid_rows};
    public int waysOrLines = {ways_or_lines};
    public float targetRtp = {target_rtp}f;
    public float maxWinMultiplier = {max_win}f;
    public string volatility = "{volatility}";
    public string[] targetMarkets = new string[] {{ {markets_cs} }};
    public string artStyle = "{art_style}";

    // Symbol definitions loaded from paytable.json
    public SymbolData[] symbols;

    // Reel strip data loaded from reelstrips.json
    public int[][] reelStrips;

    // Feature configs loaded from features.json
    public FeatureData[] features;
}}

[Serializable]
public class SymbolData
{{
    public string name;
    public string tier;        // high_pay, low_pay, wild, scatter, bonus
    public string spritePath;  // Path in Sprites/Symbols/
    public int pay3oak;
    public int pay4oak;
    public int pay5oak;
}}

[Serializable]
public class FeatureData
{{
    public string name;
    public string type;
    public string triggerCondition;
    public string description;
}}

/// <summary>
/// Loader utility — reads JSON data from Resources/Data/
/// </summary>
public static class SlotDataLoader
{{
    public static SlotConfig LoadConfig()
    {{
        var json = Resources.Load<TextAsset>("Data/config");
        return JsonUtility.FromJson<SlotConfig>(json.text);
    }}

    public static T LoadJson<T>(string resourceName)
    {{
        var json = Resources.Load<TextAsset>($"Data/{{resourceName}}");
        return JsonUtility.FromJson<T>(json.text);
    }}
}}
'''

# ─── GDScript Template for Godot ───

GODOT_SLOT_DATA_GD = '''# Auto-generated by ARKAINBRAIN Pipeline
# Game: {game_title}
# Generated: {generated_at}
#
# Usage: Preload this script or load JSON files from res://data/

extends Resource
class_name SlotData

const GAME_TITLE := "{game_title}"
const GRID_COLS := {grid_cols}
const GRID_ROWS := {grid_rows}
const WAYS_OR_LINES := {ways_or_lines}
const TARGET_RTP := {target_rtp}
const MAX_WIN_MULTIPLIER := {max_win}
const VOLATILITY := "{volatility}"
const TARGET_MARKETS := [{markets_gd}]
const ART_STYLE := "{art_style}"


static func load_config() -> Dictionary:
    var file := FileAccess.open("res://data/config.json", FileAccess.READ)
    if file == null:
        push_error("Failed to load config.json")
        return {{}}
    var json := JSON.new()
    json.parse(file.get_as_text())
    return json.data


static func load_paytable() -> Array:
    var file := FileAccess.open("res://data/paytable.json", FileAccess.READ)
    if file == null:
        push_error("Failed to load paytable.json")
        return []
    var json := JSON.new()
    json.parse(file.get_as_text())
    return json.data


static func load_reel_strips() -> Array:
    var file := FileAccess.open("res://data/reelstrips.json", FileAccess.READ)
    if file == null:
        push_error("Failed to load reelstrips.json")
        return []
    var json := JSON.new()
    json.parse(file.get_as_text())
    return json.data


static func load_features() -> Array:
    var file := FileAccess.open("res://data/features.json", FileAccess.READ)
    if file == null:
        push_error("Failed to load features.json")
        return []
    var json := JSON.new()
    json.parse(file.get_as_text())
    return json.data


static func get_symbol_sprite(symbol_name: String) -> Texture2D:
    var path := "res://sprites/symbols/%s.png" % symbol_name.to_lower().replace(" ", "_")
    if ResourceLoader.exists(path):
        return load(path) as Texture2D
    return null
'''

# ─── Godot .tres Resource Template ───

GODOT_TRES_TEMPLATE = '''[gd_resource type="Resource" script_class="SlotData" load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/slot_data.gd" id="1"]

[resource]
script = ExtResource("1")
'''


def _parse_paytable_csv(csv_text: str) -> list[dict]:
    """Parse paytable.csv into structured symbol data."""
    symbols = []
    csv_text = csv_text.strip()
    if not csv_text:
        return symbols
    reader = csv.DictReader(io.StringIO(csv_text))
    for row in reader:
        name = row.get("Symbol", row.get("symbol", row.get("Name", row.get("name", ""))))
        if not name:
            continue
        sym = {"name": name, "tier": "low_pay"}

        # Detect tier from name patterns
        name_lower = name.lower().strip()
        if "wild" in name_lower:
            sym["tier"] = "wild"
        elif "scatter" in name_lower:
            sym["tier"] = "scatter"
        elif "bonus" in name_lower:
            sym["tier"] = "bonus"
        elif name_lower in ("10", "j", "q", "k", "a", "jack", "queen", "king", "ace", "nine", "9"):
            sym["tier"] = "low_pay"
        else:
            sym["tier"] = "high_pay"

        # Extract pay values
        for col_key in row:
            col_lower = col_key.lower().strip()
            try:
                val = int(float(row[col_key]))
            except (ValueError, TypeError):
                continue
            if "3" in col_lower or "3oak" in col_lower or "three" in col_lower:
                sym["pay3oak"] = val
            elif "4" in col_lower or "4oak" in col_lower or "four" in col_lower:
                sym["pay4oak"] = val
            elif "5" in col_lower or "5oak" in col_lower or "five" in col_lower:
                sym["pay5oak"] = val

        sym.setdefault("pay3oak", 0)
        sym.setdefault("pay4oak", 0)
        sym.setdefault("pay5oak", 0)
        symbols.append(sym)

    return symbols


def _parse_reel_strips_csv(csv_text: str) -> list[list[str]]:
    """Parse BaseReels.csv into array of reel strips."""
    reels = []
    csv_text = csv_text.strip()
    if not csv_text:
        return reels
    reader = csv.reader(io.StringIO(csv_text))
    header = next(reader, None)
    if not header:
        return reels

    # Initialize reel columns
    num_reels = len(header)
    reel_data = [[] for _ in range(num_reels)]

    for row in reader:
        for i, val in enumerate(row):
            if i < num_reels and val.strip():
                reel_data[i].append(val.strip())

    return [r for r in reel_data if r]


def _extract_features(gdd_text: str, requested_features: list[str]) -> list[dict]:
    """Extract feature configs from GDD text + requested features."""
    features = []
    for feat in requested_features:
        feat_name = feat.replace("_", " ").title()
        feature = {
            "name": feat_name,
            "type": feat,
            "triggerCondition": "",
            "description": "",
        }

        # Try to find trigger conditions in GDD
        feat_lower = feat.replace("_", " ").lower()
        lines = gdd_text.split("\n") if gdd_text else []
        capture_next = False
        for line in lines:
            line_lower = line.lower()
            if feat_lower in line_lower and ("trigger" in line_lower or "activate" in line_lower):
                feature["triggerCondition"] = line.strip()[:200]
            elif feat_lower in line_lower:
                if not feature["description"]:
                    feature["description"] = line.strip()[:300]

        # Default descriptions
        DEFAULT_TRIGGERS = {
            "free_spins": "3+ Scatter symbols anywhere on reels",
            "multipliers": "Triggered during feature rounds",
            "expanding_wilds": "Wild symbol expands to cover entire reel",
            "cascading_reels": "Winning symbols removed, new symbols fall",
            "hold_and_spin": "6+ special symbols trigger hold and spin",
            "bonus_buy": "Player purchases direct entry to bonus round",
            "scatter_pays": "Scatter symbols pay in any position",
            "progressive_jackpot": "Random trigger or special symbol combination",
            "cluster_pays": "5+ matching symbols in a cluster",
            "megaways": "Dynamic reel heights change each spin",
            "mystery_symbols": "Mystery symbols transform to matching symbol",
            "walking_wilds": "Wild moves one position each spin",
            "split_symbols": "Symbols can split into multiple copies",
        }
        if not feature["triggerCondition"]:
            feature["triggerCondition"] = DEFAULT_TRIGGERS.get(feat, "See GDD for details")

        features.append(feature)

    return features


def generate_export_package(
    output_dir: str,
    format: str = "unity",
    game_title: str = "Untitled Slot",
    game_params: dict = None,
    gdd_text: str = "",
) -> str:
    """
    Generate engine-ready asset package as a ZIP file.

    Args:
        output_dir: Pipeline output directory (contains 02_design/, 03_math/, 04_art/, 04_audio/)
        format: "unity", "godot", or "generic"
        game_title: Game title for code generation
        game_params: Dict with grid_cols, grid_rows, ways_or_lines, target_rtp, max_win, volatility, etc.

    Returns:
        Path to generated ZIP file.
    """
    if game_params is None:
        game_params = {}

    od = Path(output_dir)
    export_dir = od / "09_export"
    export_dir.mkdir(parents=True, exist_ok=True)

    slug = game_title.lower().replace(" ", "_").replace("'", "")[:30]
    zip_name = f"{slug}_{format}_export.zip"
    zip_path = export_dir / zip_name

    # ── Collect source data ──
    # Paytable
    paytable_csv = ""
    for pt_name in ["paytable.csv"]:
        pt_path = od / "03_math" / pt_name
        if pt_path.exists():
            paytable_csv = pt_path.read_text(encoding="utf-8", errors="replace")
            break

    symbols = _parse_paytable_csv(paytable_csv) if paytable_csv else []

    # Reel strips
    reel_csv = ""
    for reel_name in ["BaseReels.csv", "reel_strips.csv"]:
        reel_path = od / "03_math" / reel_name
        if reel_path.exists():
            reel_csv = reel_path.read_text(encoding="utf-8", errors="replace")
            break

    reel_strips = _parse_reel_strips_csv(reel_csv) if reel_csv else []

    # Simulation results
    sim_data = {}
    sim_path = od / "03_math" / "simulation_results.json"
    if sim_path.exists():
        try:
            sim_data = json.loads(sim_path.read_text(encoding="utf-8", errors="replace"))
        except Exception:
            pass

    # GDD text
    if not gdd_text:
        for gdd_name in ["gdd.md", "gdd.txt"]:
            gdd_path = od / "02_design" / gdd_name
            if gdd_path.exists():
                gdd_text = gdd_path.read_text(encoding="utf-8", errors="replace")
                break

    # Features
    requested_features = game_params.get("features", [])
    if isinstance(requested_features, str):
        requested_features = [f.strip() for f in requested_features.split(",")]
    features = _extract_features(gdd_text, requested_features)

    # Revenue data
    rev_data = {}
    rev_path = od / "08_revenue" / "revenue_projection.json"
    if rev_path.exists():
        try:
            rev_data = json.loads(rev_path.read_text(encoding="utf-8", errors="replace"))
        except Exception:
            pass

    # ── Build config.json ──
    config = {
        "game_title": game_title,
        "grid_cols": game_params.get("grid_cols", 5),
        "grid_rows": game_params.get("grid_rows", 3),
        "ways_or_lines": game_params.get("ways_or_lines", 243),
        "target_rtp": game_params.get("target_rtp", 96.0),
        "measured_rtp": sim_data.get("measured_rtp"),
        "max_win_multiplier": game_params.get("max_win", 5000),
        "volatility": game_params.get("volatility", "medium"),
        "art_style": game_params.get("art_style", ""),
        "target_markets": game_params.get("markets", "").split(", ") if isinstance(game_params.get("markets"), str) else game_params.get("markets", []),
        "generated_at": datetime.now().isoformat(),
        "pipeline_version": "6.0",
    }

    # ── Build paytable.json ──
    paytable_json = []
    for sym in symbols:
        entry = {**sym}
        # Add sprite path based on format
        sym_slug = sym["name"].lower().replace(" ", "_")
        if format == "unity":
            entry["spritePath"] = f"Sprites/Symbols/{sym_slug}"
        elif format == "godot":
            entry["spritePath"] = f"res://sprites/symbols/{sym_slug}.png"
        else:
            entry["spritePath"] = f"symbols/{sym_slug}.png"
        paytable_json.append(entry)

    # ── Build features.json ──
    features_json = features

    # ── Build reelstrips.json ──
    reelstrips_json = reel_strips

    # ── Code generation params ──
    grid_cols = game_params.get("grid_cols", 5)
    grid_rows = game_params.get("grid_rows", 3)
    ways_or_lines = game_params.get("ways_or_lines", 243)
    target_rtp = game_params.get("target_rtp", 96.0)
    max_win = game_params.get("max_win", 5000)
    volatility = game_params.get("volatility", "medium")
    art_style = game_params.get("art_style", "Cinematic realism")
    markets = game_params.get("markets", "")
    if isinstance(markets, list):
        markets_list = markets
    else:
        markets_list = [m.strip() for m in str(markets).split(",") if m.strip()]

    generated_at = datetime.now().isoformat()

    # ── Create ZIP ──
    with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:

        if format == "unity":
            prefix = "unity_export"
            _build_unity_package(
                zf, prefix, game_title, config, paytable_json, reelstrips_json,
                features_json, od, grid_cols, grid_rows, ways_or_lines,
                target_rtp, max_win, volatility, art_style, markets_list,
                generated_at, sim_data, rev_data,
            )

        elif format == "godot":
            prefix = "godot_export"
            _build_godot_package(
                zf, prefix, game_title, config, paytable_json, reelstrips_json,
                features_json, od, grid_cols, grid_rows, ways_or_lines,
                target_rtp, max_win, volatility, art_style, markets_list,
                generated_at, sim_data, rev_data,
            )

        else:  # generic
            prefix = "generic_export"
            _build_generic_package(
                zf, prefix, config, paytable_json, reelstrips_json,
                features_json, od, sim_data, rev_data,
            )

    return str(zip_path)


def _add_assets(zf: zipfile.ZipFile, od: Path, sprites_prefix: str, audio_prefix: str):
    """Add art and audio assets to ZIP."""
    # Symbols
    art_dir = od / "04_art"
    if art_dir.exists():
        for img in art_dir.rglob("*"):
            if img.is_file() and img.suffix.lower() in (".png", ".jpg", ".webp"):
                name = img.stem.lower().replace(" ", "_")
                # Categorize by name
                if any(k in name for k in ("background", "bg", "backdrop")):
                    arc = f"{sprites_prefix}/Backgrounds/{img.name}"
                elif any(k in name for k in ("logo", "title", "ui", "button")):
                    arc = f"{sprites_prefix}/UI/{img.name}"
                else:
                    arc = f"{sprites_prefix}/Symbols/{img.name}"
                zf.write(img, arc)

    # Audio
    audio_dir = od / "04_audio"
    if audio_dir.exists():
        for snd in audio_dir.rglob("*"):
            if snd.is_file() and snd.suffix.lower() in (".mp3", ".wav", ".ogg"):
                zf.write(snd, f"{audio_prefix}/{snd.name}")


def _build_unity_package(zf, prefix, game_title, config, paytable, reels, features,
                          od, grid_cols, grid_rows, ways, rtp, max_win, vol, art_style,
                          markets, generated_at, sim_data, rev_data):
    """Build Unity-structured ZIP."""
    # Data files (as Resources/)
    zf.writestr(f"{prefix}/Resources/Data/config.json", json.dumps(config, indent=2))
    zf.writestr(f"{prefix}/Resources/Data/paytable.json", json.dumps(paytable, indent=2))
    zf.writestr(f"{prefix}/Resources/Data/reelstrips.json", json.dumps(reels, indent=2))
    zf.writestr(f"{prefix}/Resources/Data/features.json", json.dumps(features, indent=2))
    if sim_data:
        zf.writestr(f"{prefix}/Resources/Data/simulation_results.json", json.dumps(sim_data, indent=2))
    if rev_data:
        zf.writestr(f"{prefix}/Resources/Data/revenue_projection.json", json.dumps(rev_data, indent=2))

    # C# script
    markets_cs = ", ".join(f'"{m}"' for m in markets)
    cs_code = UNITY_SLOT_CONFIG_CS.format(
        game_title=game_title.replace('"', '\\"'),
        generated_at=generated_at,
        grid_cols=grid_cols, grid_rows=grid_rows,
        ways_or_lines=ways, target_rtp=rtp,
        max_win=max_win, volatility=vol,
        markets_cs=markets_cs, art_style=art_style.replace('"', '\\"'),
    )
    zf.writestr(f"{prefix}/Scripts/SlotConfig.cs", cs_code)

    # Assets
    _add_assets(zf, od, f"{prefix}/Sprites", f"{prefix}/Audio/SFX")

    # Raw CSVs for reference
    for csv_name in ["paytable.csv", "BaseReels.csv", "FreeReels.csv"]:
        csv_path = od / "03_math" / csv_name
        if csv_path.exists():
            zf.write(csv_path, f"{prefix}/RawData/{csv_name}")

    # README
    readme = _generate_readme("Unity", game_title, config, len(paytable), len(reels), len(features))
    zf.writestr(f"{prefix}/README.md", readme)


def _build_godot_package(zf, prefix, game_title, config, paytable, reels, features,
                          od, grid_cols, grid_rows, ways, rtp, max_win, vol, art_style,
                          markets, generated_at, sim_data, rev_data):
    """Build Godot-structured ZIP."""
    # Data files
    zf.writestr(f"{prefix}/data/config.json", json.dumps(config, indent=2))
    zf.writestr(f"{prefix}/data/paytable.json", json.dumps(paytable, indent=2))
    zf.writestr(f"{prefix}/data/reelstrips.json", json.dumps(reels, indent=2))
    zf.writestr(f"{prefix}/data/features.json", json.dumps(features, indent=2))
    if sim_data:
        zf.writestr(f"{prefix}/data/simulation_results.json", json.dumps(sim_data, indent=2))
    if rev_data:
        zf.writestr(f"{prefix}/data/revenue_projection.json", json.dumps(rev_data, indent=2))

    # GDScript
    markets_gd = ", ".join(f'"{m}"' for m in markets)
    gd_code = GODOT_SLOT_DATA_GD.format(
        game_title=game_title.replace('"', '\\"'),
        generated_at=generated_at,
        grid_cols=grid_cols, grid_rows=grid_rows,
        ways_or_lines=ways, target_rtp=rtp,
        max_win=max_win, volatility=vol,
        markets_gd=markets_gd, art_style=art_style.replace('"', '\\"'),
    )
    zf.writestr(f"{prefix}/scripts/slot_data.gd", gd_code)

    # .tres resource
    zf.writestr(f"{prefix}/data/slot_config.tres", GODOT_TRES_TEMPLATE)

    # Assets (Godot uses lowercase)
    _add_assets(zf, od, f"{prefix}/sprites", f"{prefix}/audio")

    # Raw CSVs
    for csv_name in ["paytable.csv", "BaseReels.csv", "FreeReels.csv"]:
        csv_path = od / "03_math" / csv_name
        if csv_path.exists():
            zf.write(csv_path, f"{prefix}/raw_data/{csv_name}")

    # README
    readme = _generate_readme("Godot", game_title, config, len(paytable), len(reels), len(features))
    zf.writestr(f"{prefix}/README.md", readme)


def _build_generic_package(zf, prefix, config, paytable, reels, features, od, sim_data, rev_data):
    """Build generic engine-agnostic ZIP."""
    zf.writestr(f"{prefix}/data/config.json", json.dumps(config, indent=2))
    zf.writestr(f"{prefix}/data/paytable.json", json.dumps(paytable, indent=2))
    zf.writestr(f"{prefix}/data/reelstrips.json", json.dumps(reels, indent=2))
    zf.writestr(f"{prefix}/data/features.json", json.dumps(features, indent=2))
    if sim_data:
        zf.writestr(f"{prefix}/data/simulation_results.json", json.dumps(sim_data, indent=2))
    if rev_data:
        zf.writestr(f"{prefix}/data/revenue_projection.json", json.dumps(rev_data, indent=2))

    _add_assets(zf, od, f"{prefix}/sprites", f"{prefix}/audio")

    for csv_name in ["paytable.csv", "BaseReels.csv", "FreeReels.csv"]:
        csv_path = od / "03_math" / csv_name
        if csv_path.exists():
            zf.write(csv_path, f"{prefix}/csv/{csv_name}")

    readme = _generate_readme("Generic", config.get("game_title", "Untitled"), config,
                               len(paytable), len(reels), len(features))
    zf.writestr(f"{prefix}/README.md", readme)


def _generate_readme(engine: str, game_title: str, config: dict,
                      num_symbols: int, num_reels: int, num_features: int) -> str:
    """Generate integration README."""
    engine_specific = ""
    if engine == "Unity":
        engine_specific = """
## Unity Integration

1. Import this folder into your Unity project's `Assets/` directory
2. Scripts are in `Scripts/SlotConfig.cs` — attach to a manager GameObject
3. JSON data is in `Resources/Data/` — loaded via `Resources.Load<TextAsset>()`
4. Sprites are in `Sprites/` — set import type to "Sprite (2D and UI)"
5. Audio is in `Audio/SFX/` — assign to AudioSource components

### Loading Data
```csharp
var config = SlotDataLoader.LoadConfig();
Debug.Log($"Game: {config.gameTitle}, RTP: {config.targetRtp}%");
```

### Symbol Sprites
Sprites are named to match paytable entries. Use `symbol.spritePath` to load:
```csharp
var sprite = Resources.Load<Sprite>(symbol.spritePath);
```
"""
    elif engine == "Godot":
        engine_specific = """
## Godot Integration

1. Copy this folder into your Godot project's `res://` directory
2. GDScript data loader is in `scripts/slot_data.gd`
3. JSON data is in `data/` — loaded via `FileAccess`
4. Sprites are in `sprites/` — auto-imported as Texture2D
5. Audio is in `audio/` — auto-imported as AudioStream

### Loading Data
```gdscript
var config = SlotData.load_config()
print("Game: %s, RTP: %s%%" % [config.game_title, config.target_rtp])
```

### Symbol Sprites
```gdscript
var sprite = SlotData.get_symbol_sprite("pharaoh")
$SymbolSprite.texture = sprite
```
"""
    else:
        engine_specific = """
## Generic Integration

JSON data files are in `data/`. Parse with your engine's JSON library.
Sprites and audio are in their respective directories.
CSV source files are in `csv/` for custom parsing.
"""

    grid = f"{config.get('grid_cols', 5)}x{config.get('grid_rows', 3)}"
    rtp = config.get("target_rtp", 96.0)
    mrtp = config.get("measured_rtp")
    rtp_line = f"Measured RTP: {mrtp}%" if mrtp else f"Target RTP: {rtp}%"

    return f"""# {game_title} — {engine} Export Package

Generated by **ARKAINBRAIN Pipeline v6.0**
Date: {config.get('generated_at', 'N/A')}

## Game Specifications

| Parameter | Value |
|-----------|-------|
| Grid | {grid} |
| Ways/Lines | {config.get('ways_or_lines', 243)} |
| {rtp_line} | |
| Max Win | {config.get('max_win_multiplier', 5000)}x |
| Volatility | {config.get('volatility', 'medium')} |
| Symbols | {num_symbols} |
| Reel Strips | {num_reels} |
| Features | {num_features} |

## Package Contents

```
data/
  config.json        — Game parameters and metadata
  paytable.json      — Symbol definitions with pay values
  reelstrips.json    — Reel strip arrays (base game)
  features.json      — Feature trigger conditions and configs
sprites/
  symbols/           — DALL-E generated symbol art (PNG)
  backgrounds/       — Background images
  ui/                — Logo and UI elements
audio/
  *.mp3              — ElevenLabs generated sound effects
```
{engine_specific}
## Data Format Notes

### paytable.json
Array of symbol objects with `name`, `tier`, `pay3oak`, `pay4oak`, `pay5oak`, `spritePath`.

### reelstrips.json
Array of arrays — each inner array is one reel's symbol sequence (top to bottom).

### features.json
Array of feature objects with `name`, `type`, `triggerCondition`, `description`.

### config.json
Master configuration with grid size, RTP, volatility, and market targets.

---
*This package was generated automatically. Verify all math and compliance data before production use.*
"""
